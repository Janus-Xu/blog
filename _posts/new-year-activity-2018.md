---
title: 自如2018新年活动
date: 2018-01-30 08:00:00
tags:
- PHP
- 分布式
categories:
- 分布式
---

2017 年是自如快速增长的一年，我们新开通了 6 个城市，自如客突破 100 万，管理资产达到 50 万间。以这么优异的成绩，我们在年底成功获得了 40 亿 A 轮融资，而这些都要感谢广大的自如客，公司为了回馈自如客，我们在六周年活动时共计发放了 6000 万租住基金，当然年底散币活动也必须有。

![2018口碑年](https://img.fanhaobai.com/2018/01/new-year-activity-2018/a3f34d9b-55cd-4931-8557-63f9b6767a79.jpg)<!--more-->

## 活动规模

既然公司对自如客这么阔，那对我们员工也得够意思，所以年底我们共准备了 3 个活动。

1. 针对 [自如客]() 的服务费减免活动；
2. 针对 [自如客]() 的 1000 万现金礼包；
3. 25 万的 [员工]() 红包活动；

![员工红包活动](https://img.fanhaobai.com/2018/01/new-year-activity-2018/b19eec7a-978b-4ddc-8c8b-13c643c27b48.png)

散币活动 2 和 3 是通过微信红包形式进行，想散币就散吧，公司高兴就行，可微信告诉我们，想散币还得交税（冏），拿员工红包来说，25 万就要交 10 多万税，此时心疼我的钱。

## 技术方案

### 红包

说到红包，我们肯定会想到红包拆分和抢红包两个场景。红包拆分是指将指定金额拆分为指定数目红包的过程，即是用来确定每个红包的金额数；而抢红包就是典型的高并发场景，需要避免红包超发的情况。

#### 红包拆分

** 可选的方案 **

[拆分方式]()

1. 实时拆分

实时拆分，指的是在抢红包时实时计算每个红包的金额，以实现红包的拆分过程，对系统性能和拆分算法要求较高，例如拆分过程要一直保证后续待拆分红包的金额不能为空，不容易做到拆分红包的金额服从正态分布规律。

2. 预算生成

预先生成，指的是在红包开抢之前已经完成了红包的拆分，抢红包时只是依次取出拆分好的红包金额，对拆分算法要求较低，可以拆分出随机性很好的红包金额，通常需要结合队列使用。

[拆分算法]()

我并没有找到业界的通用算法，但红包拆分算法应该是拆分金额要看起来随机，最好能够服从正态分布，可以参考 [微信](https://www.zybuluo.com/yulin718/note/93148) 和  [@lcode](https://www.fanhaobai.com/2017/02/reward.html) 提供的红包拆分算法。

微信拆分算法的优点是算法较简单，拆分效率高，同时，由于该算法天然的特性，可以保证后续红包金额一定不为空，特别适合实时拆分场景，但缺点是会导致大额红包较大概率地在拆分的最后出现。 [@lcode]() 拆分算法的优点是拆分金额基本符合正态分布，适合随机性要求较高的拆分场景。

** 我们的方案 **

我们这次的业务对红包金额的随机性要求不高，但是对系统可靠性要求较高，所以我们选用了预算生成方式，并借鉴 [微信]() 的红包拆分算法，作为我们的红包拆分方案。

采用预算生成方式，我们预先生成红包并放入 Redis 的 List 中，当抢红包时只是 Pop List 即可，具体实现将在 [抢红包](#抢红包) 部分介绍。

拆分算法可以描述为：假设剩余拆分金额为 M，剩余待拆分红包个数为 N，红包最小金额为 1 元，红包最小单位为元，那么定义当前红包的金额为：

$$m = rand(1, floor(M/N*2))$$

其中，floor 表示向下取整，rand(min, max) 表示从 [min, max] 区间随机一个值。$M/N*2$ 表示剩余待拆分金额平均金额的 2 倍，因为 N >= 2，所以 M/N*2 <= M，表示一定能保证后续红包能拆分到金额。

代码实现为：

```PHP
for ($i = 0; $i < $N - 1; $i++) {
    $max = (int)floor($M / ($N - $i)) * 2;
    $m[$i] = $max ? mt_rand(1, $max) : 0;
    $M -= $m[$i];
}

$m[] = $M;
```

值得一提的是，我们为了保证红包金额差异尽量小，先将总金额平均拆分成 N+1 份，将第 N+1 份红包按照上述的红包拆分算法拆分成 N 份，这 N 份红包加上之前的平均金额才作为最终的红包金额。

#### 抢红包

** 可选的方案 **

[限流]()

1. 前端限流

前端限制用户在 n 秒之内只能提交一次请求，虽然这种方式只能挡住小白，不过这是 99% 的用户哟，所以也必须得做。

2. 后端 [漏桶算法](https://www.cnblogs.com/shanyou/p/4280546.html) 和 [牌桶算法](https://www.cnblogs.com/shanyou/p/4280546.html)；

[防超发]()

1. 库存加锁；

2. 通过高速队列串行化请求；

高速队列可以使用 Redis 缓存服务器来实现。

** 我们的方案 **

由于我们预估的请求量还在系统承受范围，所以没有考虑引入限流方案。

[抢红包流程图](https://img.fanhaobai.com/2018/01/new-year-activity-2018/f405ee75-8e06-4f72-a8c5-60a155cc0ead.png)

### 员工系统号散列

由于要获取员工信息，所以接入了公司的 HR 系统，员工都用唯一一个系统号 emp_code（自增字段）标识，登录成功后返回 emp_code，系统后续所有交互流程都基于 emp_code，分享出去的红包也会携带 emp_code，为了保护员工敏感信息和防止恶意碰撞攻击，我们不能直接将 emp_code 暴露给前端，需要借助一个 token（无规律）的中间者来完成交互。

** 可选的方案 **

1. 储存映射关系，时时查询

预先生成一个随机串 token，然后跟 emp_code 绑定，每次请求都根据 token 时时查询 emp_code。优点是可以定期更新，相对安全，缺点是性能不高。

2. 建立映射关系函数，实时计算

建立一个映射关系函数，如 hash 散列或者加密解密算法，能够根据 emp_code 生成一个无规律的字符串 token，并且要能够根据 token 反映射出 emp_code。优点是需要存储介质存储关系，性能较高，缺点是很难做到定期失效并更新。

** 我们的方案 **

由于我们的红包活动只进行几天，所以我们选用了方案 2。对 emp_code 做了 [hashids](http://hashids.org/php/) 散列算法，暴露的只是一串无规律的散列字符串。

hashids 是一个开源且轻量的唯一 id 生成器，支持 Java、PHP、C/C++、Python 等主流语言，PHP 想使用 hashids，只需`composer require hashids/hashids`命令安装即可。

然后，如下方式使用：

```PHP
use Hashids\Hashids;

$hashids = new Hashids('salt', 6, 'abcdefghijk1234567890');

$hashids->encode(11002);    //994k2kk
$hashids->decode(994k2kk);  //[11002]
```

需要说明的是，其中`salt`是非常重要的散列加密盐串，`6`表示散列值最小长度，`abcde...7890`为散列字典，太长影响效率，太短不安全。由于默认的散列字典比较长，decode 效率并不高，所以这里移除了大写字母部分。

### 语音点赞



## 问题

### 测试环境发放红包限制

在测试红包过程中，我们遇到了一个不算问题的问题。由于运营将测试资金充值到线上的微信公众号中，所以还必须使用线上公众号授权的 openid 进行测试（否则会出现 openid 与公众号不一致问题）。为了让线上公众号能够授权到测试环境，我们测试时在线上的微信授权回调地址新增一个参数做区分，将带有`to=feature`参数的请求引流到测试环境，其他线上正常流量还是保持不变，匹配规则如下：

```Nginx
# Nginx不支持if嵌套，所以就这样变通实现
set $auth_redirect "";
if ($args ~* "r=auth/redirect") {
    set $auth_redirect "prod";
}
if ($args ~* "to=feature") {
    set $auth_redirect "feature";
}
if ($auth_redirect ~ "feature") {
    rewrite ^(.*)$ http://wx.t.ziroom.com/index.php last;
}
if ($auth_redirect ~ "prod") {
    rewrite ^(.*)$ http://wx.ziroom.com/index.php last;
}
```

## 灾备方案