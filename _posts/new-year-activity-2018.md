---
title: 自如2018新年活动
date: 2018-01-30 08:00:00
tags:
- PHP
- 分布式
categories:
- 分布式
---

2017 年是自如快速增长的一年，我们新开通了 6 个城市，自如客突破 100 万，管理资产达到 50 万间。以这么优异的成绩，我们在年底成功获得了 40 亿 A 轮融资，而这些都要感谢广大的自如客，公司为了回馈自如客，我们在六周年活动时共计发放了 6000 万租住基金，当然年底散币活动也必须有。![](https://img.fanhaobai.com/2018/01/new-year-activity-2018/a3f34d9b-55cd-4931-8557-63f9b6767a79.jpg)<!--more-->

## 活动规模

既然公司对自如客这么阔，那对我们员工也得够意思，所以年底我们共准备了 3 个活动。

1. 针对 [自如客]() 的服务费减免活动；
2. 针对 [自如客]() 的 1000 万现金礼包；
3. 25 万的 [员工]() 红包活动；

![流程图]()

散币活动 2 和 3 是通过微信红包形式进行，想散币就散吧，公司高兴就行，可微信告诉我们，想散币还得交税（冏），拿员工红包来说，25 万就要交 10 多万税，此时心疼我的钱。

## 技术方案

### 红包

说到红包，我们肯定会想到红包拆分和抢红包两个场景。红包拆分是指将指定金额拆分为指定数目红包的过程，即是用来确定每个红包的金额数；而抢红包就是典型的高并发场景，需要避免红包超发的情况。

#### 红包拆分

红包拆分通常采用预先拆分和实时拆分两种方法。实时拆分对系统计算性能和可靠性要求较高，而这次的业务也属于预先拆分场景，所以我们这里借鉴 [微信](https://www.zybuluo.com/yulin718/note/93148) 曾经使用过的红包拆分算法，实现红包的预先拆分。

拆分算法可以描述为：假设剩余拆分金额为 M，剩余待拆分红包个数为 N，红包最小金额为 1 元，红包最小单位为元，那么定义当前红包的金额为：

$$m = rand(1, floor(M/N*2))$$

其中，floor 表示向下取整，rand(min, max) 表示从 [min, max] 区间随机一个值。$M/N*2$ 表示剩余待拆分金额平均金额的 2 倍，因为 N >= 2，所以 M/N*2 <= M，表示一定能保证后续红包能拆分到金额。

代码实现为：

```PHP
for ($i = 0; $i < $N - 1; $i++) {
    $max = (int)floor($M / ($N - $i)) * 2;
    $m[$i] = $max ? mt_rand(1, $max) : 0;
    $M -= $m[$i];
}

$m[] = $M;
```

值得一提的是，我们为了保证红包金额差异尽量小，先将总金额平均拆分成 N+1 份，将第 N+1 份红包按照上述的红包拆分算法拆分成 N 份，这 N 份红包加上之前的平均金额才作为最终的红包金额。

> 这种红包拆分算法，会导致大额红包较大概率出现在拆分的最后，但是在当前业务场景下又无须要求拆分红包的金额满足正态分布，所以可以忽略。

#### 抢红包

抢红包通常采用流量限流结合队列的方法，一个用来减少后端服务处理的请求量，另一个用来串行化请求。当然，流量限流有很多办法，如前端随机过滤、后端的 [漏桶算法](https://www.cnblogs.com/shanyou/p/4280546.html) 和 [牌桶算法](https://www.cnblogs.com/shanyou/p/4280546.html)，队列可以直接使用缓存服务器（Redis），由于我们预估的请求量还在系统承受范围，所以没有考虑引入限流方法。




### 员工系统号散列

由于要获取员工信息，所以接入了公司的 HR 系统，员工都用唯一一个系统号 emp_code（自增字段）标识，登录成功后返回 emp_code，系统后续所有交互流程都基于 emp_code，分享出去的红包也会携带 emp_code，为了保护员工敏感信息和防止恶意碰撞攻击，我们对 emp_code 做了 [hashids](http://hashids.org/php/) 散列算法，前端展示的只是一串无规律字符串。

hashids 是一个开源且轻量的唯一 id 生成器，支持 Java、PHP、C/C++、Python 等主流语言，PHP 想使用 hashids，只需`composer require hashids/hashids`命令安装即可。

然后，如下方式使用：

```PHP
use Hashids\Hashids;

$hashids = new Hashids('salt', 6, 'abcdefghijk1234567890');

$hashids->encode(11002);    //994k2kk
$hashids->decode(994k2kk);  //[11002]
```

需要说明的是，其中`salt`是非常重要的散列加密盐串，`6`表示散列值最小长度，`abcde...7890`为散列字典，太长影响效率，太短不安全。由于默认的散列字典比较长，decode 效率并不高，所以这里移除了大写字母部分。

### 语音点赞



## 流量



## 灾备方案

